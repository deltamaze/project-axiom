================================================================================
DIRECTORY STRUCTURE
================================================================================
Root directory: project-axiom
  └── Content
    ├── Content.mgcb
    └── Fonts
      ├── DefaultFont.spritefont.xml
  ├── Game1.cs
  └── GameStates
    ├── GameState.cs
    ├── MainMenuState.cs
  ├── Program.cs
  ├── project-axiom.csproj
  ├── project-axiom.sln
  ├── ProjectSync.cs
  ├── README.md
  └── UI
    ├── Button.cs


================================================================================
FILE CONTENTS
================================================================================
--------------------------------------------------------------------------------
File: Content\Content.mgcb
--------------------------------------------------------------------------------
#----------------------------- Global Properties ----------------------------#
/outputDir:bin/$(Platform)
/intermediateDir:obj/$(Platform)
/platform:DesktopGL
/config:
/profile:Reach
/compress:False

#-------------------------------- References --------------------------------#

#---------------------------------- Content ---------------------------------#
#begin Fonts/DefaultFont.spritefont
/importer:FontDescriptionImporter
/processor:FontDescriptionProcessor
/processorParam:TextureFormat=Compressed
#build Fonts/DefaultFont.spritefont


--------------------------------------------------------------------------------
File: Content\Fonts\DefaultFont.spritefont.xml
--------------------------------------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<XnaContent xmlns:Graphics="Microsoft.Xna.Framework.Content.Pipeline.Graphics">
  <Asset Type="Graphics:FontDescription">
    <FontName>Arial</FontName>
    <Size>24</Size>
    <Spacing>0</Spacing>
    <UseKerning>true</UseKerning>
    <Style>Regular</Style>
    <DefaultCharacter>*</DefaultCharacter>
    <CharacterRegions>
      <CharacterRegion>
        <Start>&#32;</Start>
        <End>&#126;</End>
      </CharacterRegion>
    </CharacterRegions>
  </Asset>
</XnaContent>


--------------------------------------------------------------------------------
File: Game1.cs
--------------------------------------------------------------------------------
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using project_axiom.GameStates; // Ensure this using directive is present

namespace project_axiom;

public class Game1 : Game
{
    private GraphicsDeviceManager _graphics;
    private SpriteBatch _spriteBatch;

    private GameState _currentState;
    private GameState _nextState;

    public void ChangeState(GameState state)
    {
        _nextState = state;
    }

    public Game1()
    {
        _graphics = new GraphicsDeviceManager(this);
        Content.RootDirectory = "Content";
        IsMouseVisible = true;
    }

    protected override void Initialize()
    {
        // Set initial screen size (optional)
        _graphics.PreferredBackBufferWidth = 1280;
        _graphics.PreferredBackBufferHeight = 720;
        _graphics.ApplyChanges();

        base.Initialize();
    }

    protected override void LoadContent()
    {
        _spriteBatch = new SpriteBatch(GraphicsDevice);

        // Initialize and load the first state (Main Menu)
        _currentState = new MainMenuState(this, _graphics.GraphicsDevice, Content);
        _currentState.LoadContent();
    }

    protected override void Update(GameTime gameTime)
    {
        // Handle state transitioning
        if (_nextState != null)
        {
            _currentState = _nextState;
            _currentState.LoadContent(); // Load content for the new state
            _nextState = null; // Clear the next state
        }

        // Update the current state
        _currentState.Update(gameTime);

        // Call PostUpdate for any logic that needs to run after the main update (e.g., state changes)
        _currentState.PostUpdate(gameTime);

        // Global escape condition (optional, can be handled within states if preferred)
        // if (Keyboard.GetState().IsKeyDown(Keys.Escape))
        //    Exit();

        base.Update(gameTime);
    }

    protected override void Draw(GameTime gameTime)
    {
        // The current state is responsible for clearing the screen and drawing
        _currentState.Draw(gameTime, _spriteBatch);

        base.Draw(gameTime);
    }
}


--------------------------------------------------------------------------------
File: GameStates\GameState.cs
--------------------------------------------------------------------------------
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace project_axiom.GameStates
{
    public abstract class GameState
    {
        protected ContentManager _content;
        protected GraphicsDevice _graphicsDevice;
        protected Game1 _game;

        public GameState(Game1 game, GraphicsDevice graphicsDevice, ContentManager content)
        {
            _game = game;
            _graphicsDevice = graphicsDevice;
            _content = content;
        }

        public abstract void LoadContent();
        public abstract void Update(GameTime gameTime);
        public abstract void Draw(GameTime gameTime, SpriteBatch spriteBatch);
        public abstract void PostUpdate(GameTime gameTime); // For handling state transitions after updates
    }
}


--------------------------------------------------------------------------------
File: GameStates\MainMenuState.cs
--------------------------------------------------------------------------------
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using project_axiom.UI;
using System.Collections.Generic;

namespace project_axiom.GameStates
{
    public class MainMenuState : GameState
    {
        private List<Button> _buttons;
        private SpriteFont _buttonFont;
        // private Texture2D _buttonTexture; // Optional: if you create a button background image

        public MainMenuState(Game1 game, GraphicsDevice graphicsDevice, ContentManager content)
          : base(game, graphicsDevice, content)
        {
        }

        public override void LoadContent()
        {
            _buttonFont = _content.Load<SpriteFont>("Fonts/DefaultFont");
            // _buttonTexture = _content.Load<Texture2D>("Path/To/Your/ButtonTexture"); // If you have one

            var loadGameButton = new Button(_buttonFont, "Load Game" /*, _buttonTexture (optional) */)
            {
                Position = new Vector2((_graphicsDevice.Viewport.Width / 2f) - 100, 200),
                PenColour = Color.AntiqueWhite, // Example text color
                BackgroundColour = new Color(50,50,100), // Example button bg color
                BackgroundHoverColour = new Color(80,80,150) // Example button bg hover color
            };
            loadGameButton.Click += LoadGameButton_Click;

            var quitButton = new Button(_buttonFont, "Quit" /*, _buttonTexture (optional) */)
            {
                Position = new Vector2((_graphicsDevice.Viewport.Width / 2f) - 100, 280),
                PenColour = Color.AntiqueWhite,
                BackgroundColour = new Color(100,50,50),
                BackgroundHoverColour = new Color(150,80,80)
            };
            quitButton.Click += QuitButton_Click;

            _buttons = new List<Button>()
            {
                loadGameButton,
                quitButton,
            };

             // Ensure button rectangles are initialized after setting position
            foreach(var button in _buttons)
            {
                 button.Position = button.Position; // This calls the setter which updates the rectangle
            }
        }

        private void LoadGameButton_Click(object sender, System.EventArgs e)
        {
            System.Diagnostics.Debug.WriteLine("Load Game Clicked!"); // Use System.Diagnostics.Debug for output
            // TODO: Transition to Load Game screen or Character Creation (as per README 6.5)
            // As a placeholder, for now, this doesn't change state.
            // Example: _game.ChangeState(new CharacterCreationState(_game, _graphicsDevice, _content));
        }

        private void QuitButton_Click(object sender, System.EventArgs e)
        {
            _game.Exit();
        }

        public override void Update(GameTime gameTime)
        {
            foreach (var button in _buttons)
                button.Update(gameTime);
        }

        public override void PostUpdate(GameTime gameTime)
        {
            // Logic to transition to another state can be put here if needed
            // For example, if a button click sets a flag to change state.
        }

        public override void Draw(GameTime gameTime, SpriteBatch spriteBatch)
        {
            _graphicsDevice.Clear(new Color(20, 20, 40)); // Dark blue background for main menu

            spriteBatch.Begin();
            foreach (var button in _buttons)
                button.Draw(spriteBatch);
            spriteBatch.End();
        }
    }
}


--------------------------------------------------------------------------------
File: Program.cs
--------------------------------------------------------------------------------
using var game = new project_axiom.Game1();
game.Run();



--------------------------------------------------------------------------------
File: project-axiom.csproj
--------------------------------------------------------------------------------
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <RollForward>Major</RollForward>
    <PublishReadyToRun>false</PublishReadyToRun>
    <TieredCompilation>false</TieredCompilation>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationManifest>app.manifest</ApplicationManifest>
    <ApplicationIcon>Icon.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <None Remove="Icon.ico" />
    <None Remove="Icon.bmp" />
    <Compile Remove="ProjectSync.cs" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Icon.ico">
      <LogicalName>Icon.ico</LogicalName>
    </EmbeddedResource>
    <EmbeddedResource Include="Icon.bmp">
      <LogicalName>Icon.bmp</LogicalName>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <PackageReference Include="MonoGame.Framework.DesktopGL" Version="3.8.*" />
    <PackageReference Include="MonoGame.Content.Builder.Task" Version="3.8.*" />
  </ItemGroup>
   <!-- <ItemGroup>
    <Compile Include="GameStates\GameState.cs" />
    <Compile Include="GameStates\MainMenuState.cs" />
    <Compile Include="UI\Button.cs" />

    </ItemGroup> -->

  <ItemGroup>
    <MonoGameContentReference Include="Content\Content.mgcb" />
  </ItemGroup>
  <Target Name="RestoreDotnetTools" BeforeTargets="Restore">
    <Message Text="Restoring dotnet tools" Importance="High" />
    <Exec Command="dotnet tool restore" />
  </Target>
</Project>


--------------------------------------------------------------------------------
File: project-axiom.sln
--------------------------------------------------------------------------------
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.5.2.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "project-axiom", "project-axiom.csproj", "{B6E812B8-3FE0-ABE7-6C27-7ED94786C44F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B6E812B8-3FE0-ABE7-6C27-7ED94786C44F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B6E812B8-3FE0-ABE7-6C27-7ED94786C44F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B6E812B8-3FE0-ABE7-6C27-7ED94786C44F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B6E812B8-3FE0-ABE7-6C27-7ED94786C44F}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C6ECA4F2-29BE-48A5-A238-DD0F1E2574DD}
	EndGlobalSection
EndGlobal



--------------------------------------------------------------------------------
File: ProjectSync.cs
--------------------------------------------------------------------------------
#!/usr/bin/env dotnet-script

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Security; // Required for SecurityException

// Configure which file extensions to include (without the dot)
var INCLUDED_EXTENSIONS = new List<string> { "cs", "csproj", "xml", "mgcb", "md", "sln" };

// --- Helper Methods ---

/**
 * Check if a file has one of the included extensions
 */
bool IsIncludedFile(string filename)
{
    string extension = Path.GetExtension(filename); // Gets ".ext"
    if (string.IsNullOrEmpty(extension)) return false;
    return INCLUDED_EXTENSIONS.Contains(extension.Substring(1).ToLowerInvariant()); // Remove dot and compare case-insensitively
}

/**
 * Check if a directory should be excluded
 */
bool ShouldExcludeDirectory(string dirname)
{
    return dirname.StartsWith(".") || dirname.Equals("bin", StringComparison.OrdinalIgnoreCase) || dirname.Equals("obj", StringComparison.OrdinalIgnoreCase);
}

/**
 * Helper to repeat a string
 */
string RepeatString(string value, int count)
{
    if (count < 0) throw new ArgumentOutOfRangeException(nameof(count), "Count cannot be negative.");
    if (count == 0 || string.IsNullOrEmpty(value)) return string.Empty;
    return new StringBuilder(value.Length * count).Insert(0, value, count).ToString();
}

/**
 * Check if a directory contains any target files (recursively) - used for pre-filtering in GetDirectoryStructureAsync
 */
async Task<bool> HasTargetFilesRecursiveCheckAsync(string dirPath)
{
    DirectoryInfo currentDirectoryInfo;
    try
    {
        currentDirectoryInfo = new DirectoryInfo(dirPath);
        if (!currentDirectoryInfo.Exists) return false;
    }
    catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
    {
        // Console.Error.WriteLine($"Debug (HasTargetFilesRecursiveCheckAsync Dir): Access or IO error for {dirPath} - {ex.Message}");
        return false; // Cannot access or doesn't exist, so treat as no target files
    }

    try
    {
        foreach (var file in currentDirectoryInfo.EnumerateFiles())
        {
            if (IsIncludedFile(file.Name))
            {
                return true;
            }
        }
    }
    catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
    {
        // Console.Error.WriteLine($"Debug (HasTargetFilesRecursiveCheckAsync Files): Access or IO error for files in {dirPath} - {ex.Message}");
        // Continue to check subdirectories even if files in current are inaccessible
    }


    try
    {
        foreach (var subDir in currentDirectoryInfo.EnumerateDirectories())
        {
            if (!ShouldExcludeDirectory(subDir.Name))
            {
                if (await HasTargetFilesRecursiveCheckAsync(subDir.FullName))
                {
                    return true;
                }
            }
        }
    }
    catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
    {
        // Console.Error.WriteLine($"Debug (HasTargetFilesRecursiveCheckAsync SubDirs): Access or IO error for subdirs in {dirPath} - {ex.Message}");
        // If subdirectories are inaccessible, cannot confirm target files there
    }

    return false;
}


/**
 * Generate a formatted string of the directory structure
 */
async Task<string> GetDirectoryStructureAsync(string startPath)
{
    var structureLines = new List<string>();

    async Task TraverseAsync(string currentPath, int level)
    {
        DirectoryInfo currentDirInfo;
        try
        {
            currentDirInfo = new DirectoryInfo(currentPath);
            if (!currentDirInfo.Exists) return;
        }
        catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
        {
            Console.Error.WriteLine($"Warning (GetDirectoryStructureAsync Traverse): Cannot access directory {currentPath}. Skipping. Error: {ex.Message}");
            return;
        }

        List<FileSystemInfo> fileSystemInfos;
        try
        {
            fileSystemInfos = currentDirInfo.EnumerateFileSystemInfos().ToList();
        }
        catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
        {
            Console.Error.WriteLine($"Warning (GetDirectoryStructureAsync Traverse): Cannot enumerate items in {currentPath}. Skipping. Error: {ex.Message}");
            return;
        }


        var indent = RepeatString("  ", level);

        bool hasTargetFilesInCurrentDir = false;
        try
        {
            foreach (var item in fileSystemInfos.OfType<FileInfo>())
            {
                if (IsIncludedFile(item.Name))
                {
                    hasTargetFilesInCurrentDir = true;
                    break;
                }
            }
        }
        catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
        {
             Console.Error.WriteLine($"Warning (GetDirectoryStructureAsync Traverse): Error checking files in {currentPath}. Error: {ex.Message}");
        }


        bool subDirHasTargetFiles = false;
        if (!hasTargetFilesInCurrentDir)
        {
            foreach (var item in fileSystemInfos.OfType<DirectoryInfo>())
            {
                if (!ShouldExcludeDirectory(item.Name))
                {
                    if (await HasTargetFilesRecursiveCheckAsync(item.FullName))
                    {
                        subDirHasTargetFiles = true;
                        break;
                    }
                }
            }
        }

        if (hasTargetFilesInCurrentDir || subDirHasTargetFiles)
        {
            var folderName = currentDirInfo.Name;
            if (level == 0)
            {
                structureLines.Add($"Root directory: {folderName}");
            }
            else
            {
                structureLines.Add($"{indent}└── {folderName}");
            }

            fileSystemInfos.Sort((a, b) => string.Compare(a.Name, b.Name, StringComparison.OrdinalIgnoreCase));

            foreach (var item in fileSystemInfos)
            {
                if (item is FileInfo fileInfo && IsIncludedFile(fileInfo.Name))
                {
                    structureLines.Add($"{indent}  ├── {fileInfo.Name}");
                }
                else if (item is DirectoryInfo dirInfo && !ShouldExcludeDirectory(dirInfo.Name))
                {
                    await TraverseAsync(dirInfo.FullName, level + 1);
                }
            }
        }
    }

    await TraverseAsync(startPath, 0);
    return string.Join("\n", structureLines);
}


/**
 * Read and return the contents of a file
 */
async Task<string> ReadFileContentsAsync(string filepath)
{
    Console.Error.WriteLine($"DEBUG: Attempting to read file: '{filepath}'"); // Log attempt
    try
    {
        string fileContent = await File.ReadAllTextAsync(filepath);
        Console.Error.WriteLine($"DEBUG: Successfully read file: '{filepath}'. Content length: {fileContent.Length}. First 50 chars: '{fileContent.Substring(0, Math.Min(fileContent.Length, 50))}'"); // Log success and snippet
        return fileContent;
    }
    catch (FileNotFoundException)
    {
        Console.Error.WriteLine($"DEBUG: File not found: '{filepath}'");
        return "[File not found]";
    }
    catch (IOException ex)
    {
        Console.Error.WriteLine($"DEBUG: IOException for '{filepath}': {ex.Message}");
        return $"[Error reading file: {ex.Message}]";
    }
    catch (UnauthorizedAccessException ex)
    {
        Console.Error.WriteLine($"DEBUG: UnauthorizedAccessException for '{filepath}': {ex.Message}");
        return $"[Access denied reading file: {ex.Message}]";
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"DEBUG: Unexpected error for '{filepath}': {ex.GetType().Name} - {ex.Message}"); // Log other errors
        Console.Error.WriteLine($"DEBUG: StackTrace: {ex.StackTrace}");
        return $"[Unexpected error reading file: {ex.Message}]";
    }
}

/**
 * Recursively collect all target files, respecting excluded directories.
 */
async Task CollectTargetFilesRecursivelyAsync(string currentPath, List<string> collectedFiles)
{
    DirectoryInfo currentDirectoryInfo;
    try
    {
        currentDirectoryInfo = new DirectoryInfo(currentPath);
        if (!currentDirectoryInfo.Exists) return;
    }
    catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
    {
        Console.Error.WriteLine($"Warning (CollectTargetFilesRecursivelyAsync): Cannot access directory {currentPath}. Skipping. Error: {ex.Message}");
        return;
    }

    // Process files
    try
    {
        foreach (var file in currentDirectoryInfo.EnumerateFiles())
        {
            if (IsIncludedFile(file.Name))
            {
                collectedFiles.Add(file.FullName);
            }
        }
    }
    catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
    {
         Console.Error.WriteLine($"Warning (CollectTargetFilesRecursivelyAsync): Cannot enumerate files in {currentPath}. Skipping files in this directory. Error: {ex.Message}");
    }

    // Process subdirectories
    try
    {
        foreach (var subDir in currentDirectoryInfo.EnumerateDirectories())
        {
            if (!ShouldExcludeDirectory(subDir.Name))
            {
                await CollectTargetFilesRecursivelyAsync(subDir.FullName, collectedFiles);
            }
        }
    }
     catch (Exception ex) when (ex is SecurityException || ex is UnauthorizedAccessException || ex is IOException)
    {
         Console.Error.WriteLine($"Warning (CollectTargetFilesRecursivelyAsync): Cannot enumerate subdirectories of {currentPath}. Skipping subdirectories. Error: {ex.Message}");
    }
}

/**
 * Get all target files paths (recursively)
 */
async Task<(bool HasFiles, List<string> FoundFiles)> GetAllTargetFilesAsync(string dirPath)
{
    var allFoundFiles = new List<string>();
    await CollectTargetFilesRecursivelyAsync(dirPath, allFoundFiles);
    allFoundFiles.Sort(StringComparer.OrdinalIgnoreCase); // Sort for consistent output
    return (allFoundFiles.Any(), allFoundFiles);
}


/**
 * Generate the complete project sync output
 */
async Task<string> GenerateProjectSyncAsync(string directoryPath)
{
    var outputLines = new List<string>();

    var (hasAnyFiles, targetFiles) = await GetAllTargetFilesAsync(directoryPath);

    if (!hasAnyFiles)
    {
        return "No files matching the specified extensions were found in accessible directories.";
    }

    outputLines.Add(RepeatString("=", 80));
    outputLines.Add("DIRECTORY STRUCTURE");
    outputLines.Add(RepeatString("=", 80));
    outputLines.Add(await GetDirectoryStructureAsync(directoryPath));
    outputLines.Add("\n");

    outputLines.Add(RepeatString("=", 80));
    outputLines.Add("FILE CONTENTS");
    outputLines.Add(RepeatString("=", 80));

    foreach (var fullPath in targetFiles)
    {
        string relativePath;
        try
        {
            relativePath = Path.GetRelativePath(directoryPath, fullPath);
        }
        catch (ArgumentException) // Can happen if paths are on different drives on Windows, etc.
        {
            relativePath = fullPath; // Fallback to full path
        }


        outputLines.Add(RepeatString("-", 80));
        outputLines.Add($"File: {relativePath}");
        outputLines.Add(RepeatString("-", 80));

        var content = await ReadFileContentsAsync(fullPath);
        outputLines.Add(content);
        outputLines.Add("\n");
    }

    return string.Join("\n", outputLines);
}

// --- Main Execution ---
try
{
    string currentDir = "";
    try
    {
        currentDir = Directory.GetCurrentDirectory();
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Fatal Error: Could not get current directory. {ex.Message}");
        Environment.Exit(1);
    }

    Console.WriteLine($"Processing directory: {currentDir}");
    var outputContent = await GenerateProjectSyncAsync(currentDir);

    var outputFile = "project_sync.txt";
    try
    {
        await File.WriteAllTextAsync(outputFile, outputContent);
        Console.WriteLine($"Project sync has been written to {Path.Combine(currentDir, outputFile)}");
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Fatal Error: Could not write to output file {outputFile}. {ex.Message}");
        Environment.Exit(1);
    }
}
catch (Exception ex)
{
    Console.Error.WriteLine($"An unexpected error occurred: {ex.Message}");
    Console.Error.WriteLine($"Stack Trace: {ex.StackTrace}");
    Environment.Exit(1);
}


--------------------------------------------------------------------------------
File: README.md
--------------------------------------------------------------------------------
## Game Design Document: Block Brawlers (Working Title) - Revised

**Document Version:** 1.1 **Date:** May 30, 2025 **Platform:** PC (Windows/macOS/Linux) via MonoGame **Development Focus:** Code-first, AI-assisted development in Visual Studio Code. Minimal reliance on visual editors.

---

### 1. Game Overview

"Block Brawlers" is a multiplayer online battleground (MOB) game with a **class-based progression system that emphasizes flexible spell selection and team synergy**. Players customize blocky, pixel-art characters, choose a **base class (Brawler, Ranger, or Spellcaster)**, and then select from a curated pool of **~30 class-specific spells** to equip 8 active abilities for battle. The core experience is driven by player choice, tactical execution, and cooperative gameplay within large-scale team battles.

### 2. Core Game Loop

1. **Launch Game:** Player launches the MonoGame application.
2. **Main Menu:** Accesses Character Creation, Game Modes, Settings, and Quit.
3. **Character Creation:** Design a pixelated character (body shape, color, simple textures), **then choose a base class (Brawler, Ranger, or Spellcaster)**.
4. **Spell Selection:** From a pool of approximately 30 spells specific to the chosen base class, select 8 active spells for the action bar.
5. **Queue for Game Mode:** Select a desired multiplayer battleground (5v5, 16v16, 32v32) or a training/practice area.
6. **Multiplayer Battleground:** Engage in objective-based PvP combat, earning experience and currency.
7. **Post-Game:** View results, earn rewards, return to main menu or re-queue.
8. **Progression:** Use earned currency to acquire new gear (minor stat improvements, aesthetic). All class spells are available from the start; there's no unlocking of additional spells within your chosen class.

### 3. Visuals & Art Style

- **Aesthetic:** Low-poly, pixelated, "boxy" art style reminiscent of early 3D games or Minecraft.
- **Characters/Mobs:** Composed entirely of textured blocks/cuboids. No traditional skeletal animation; movement will be achieved through rigid body rotations and translations of block components.
- **Environments:** Maps constructed from large, textured blocks, creating clear pathways, chokepoints, and objectives.
- **Textures:** Low-resolution, pixel-art textures applied to block surfaces to define details and materials.
- **Spells:** Visual effects for spells will be particle-based and programmatic, matching the pixelated aesthetic.
- **User Interface (UI):** Clean, functional, pixel-art inspired UI elements (buttons, health bars, spell icons) rendered directly via code.

---

### 4. Technical Requirements & Architecture Philosophy

- **Engine:** MonoGame (C#).
- **Development Environment:** Visual Studio Code.
- **Core Principle:** All game logic, UI, entity definitions, and game mode rules will be implemented in C# code. 3D assets will be defined programmatically (e.g., cube meshes generated by code) or loaded as simple, text-based data (e.g., OBJ files with associated texture paths). Textures will be simple 2D image files.
- **Networking:** Client-server architecture. Dedicated game servers for multiplayer matches. Players connect as clients.
- **Physics:** Integration of a suitable C# physics library (e.g., JoltPhysics.NET, BEPUphysics v2) for character collision, spell projectiles, and environmental interactions.
- **AI (Bots):** Implement sophisticated bot AI to fill game modes, assist with player base establishment, and provide testing capabilities. Bots should demonstrate pathfinding, target prioritization, spell usage, and objective awareness.
- **Data Serialization:** Game data (character saves, spell definitions, gear properties, map layouts) will be stored and loaded using structured formats (e.g., JSON, XML, or custom binary formats) to facilitate AI understanding and manipulation.

---

### 5. Gameplay Mechanics

#### 5.1. Character & Combat

- **Character Model:** Player character composed of basic block primitives (head, torso, arms, legs). Movement handled by translating and rotating these blocks.
- **First-Person Perspective:** Primary gameplay view is first-person. Third-person view (optional, lower priority) could be added later for character admiration.
- **Movement:** Standard WASD movement, space for jump, mouse for camera look. Sprinting mechanic.
- **Targeting:**
    - **Click-to-target:** Clicking on an enemy within a certain range highlights and locks onto them for single-target spells.
    - **Reticle-based (Skillshot):** Many spells will be skillshots, requiring direct aiming with a mouse reticle.
    - **Area-of-Effect (AoE):** Spells with a defined radius around the player or a targeted location.
- **Spell Casting:**
    - **Action Bar:** 8 customizable spell slots bound to hotkeys (1-8).
    - **Resource System:** Spells consume a class-appropriate resource (e.g., Mana for Spellcasters, Rage/Stamina for Brawlers, Energy for Rangers). Regeneration over time.
    - **Cooldowns:** Each spell has an individual cooldown.
- **Health System:** Player has a health pool. Damage reduces health. Reaching 0 health results in death.
- **Death & Respawn:** Players respawn after a short delay at a designated spawn point in battlegrounds.
- **Damage Types:** Spells can inflict different damage types (e.g., Arcane, Fire, Frost, Physical). Resistance/vulnerability system (lower priority).

#### 5.2. Base Classes & Spells

Players choose one of three base classes, each with its own thematic focus, armor type, primary resource, and a unique pool of approximately **30 spells** from which to select their 8 active abilities.

- **1. Spellcaster:**
    
    - **Theme:** Focuses on magical abilities, ranged combat, and elemental manipulation.
    - **Armor:** Light Armor (lowest base defense).
    - **Resource:** Mana (regenerates slowly, often replenished by specific spells or passive effects).
    - **Spell Examples:** Fireball, Ice Shard, Arcane Missile, Healing Word, Shield Bubble, Teleport, Chain Lightning, Polymorph, Mass Dispel, Blizzard, Drain Life, Summon Imp.
    - **Gameplay Role:** High burst damage, crowd control, healing, utility. Squishy but powerful.
    - **Inspiration:** Warlock, Mage, Priest.
- **2. Ranger:**
    
    - **Theme:** Focuses on agility, precision, stealth, and nature-based abilities.
    - **Armor:** Medium Armor (balanced defense).
    - **Resource:** Energy (regenerates quickly, often used for rapid, low-cooldown abilities).
    - **Spell Examples:** Multi-shot, Explosive Arrow, Stealth, Dash, Bear Trap, Healing Touch (minor self/ally heal), Poison Dart, Vine Snare, Beast Companion (temporary summon), Fan of Knives, Blind.
    - **Gameplay Role:** Sustained damage, mobility, debuffs, traps, opportunistic strikes.
    - **Inspiration:** Hunter, Rogue, Thief, Druid.
- **3. Brawler:**
    
    - **Theme:** Focuses on melee combat, durability, physical prowess, and direct confrontation.
    - **Armor:** Heavy Armor (highest base defense).
    - **Resource:** Rage/Stamina (generated by dealing/taking damage, or slowly over time; used for powerful offensive/defensive abilities).
    - **Spell Examples:** Charge, Slam, Taunt, Shield Wall (damage reduction), Cleave, Hamstring (slow), Ground Pound (AoE stun), Intercept, Battle Cry (team buff), Execute, Impenetrable Skin.
    - **Gameplay Role:** Tanking, front-line damage, disruptive crowd control, area denial.
    - **Inspiration:** Warrior, Death Knight, Paladin.
- **Spell Definition:** Each spell will be defined by a structured C# class or data object (e.g., `SpellData` containing name, description, resource cost, cooldown, range, damage type, cast time, and references to associated visual effects and sound effects). This is a prime area for AI assistance in defining and balancing.
    

#### 5.3. Gear & Progression

- **Gear Slots:** Head, Chest, Legs, Hands, Feet, Weapon, Trinket (2).
- **Stat Increments:** Gear provides minor statistical improvements (e.g., +Health, +Resource Pool, +Spell Power, +Cooldown Reduction). Each class benefits more from certain stats.
- **Power Ceiling:** Earned gear should provide a maximum of **10%** statistical advantage over base/starter gear. This ensures skill remains paramount.
- **Acquisition:** Earned through playing game modes (rewards for winning, performance).
- **Cash Store (Future):** Cosmetic items only. No pay-to-win elements. Aesthetic gear from the cash store should _never_ be statistically better than earned gear. This is a low-priority feature for initial development.

#### 5.4. Multiplayer & Game Modes

- **Lobby/Queue System:** Players queue for desired game modes.
- **Matchmaking:** Simple matchmaking based on queue time and game mode selection. (No complex ELO/MMR initially).
- **Dedicated Servers:** Game logic resides on dedicated servers, with clients sending input and receiving game state.
- **Game Modes:**
    - **Training Grounds:**
        - Single-player instance with static training dummies.
        - No time limit.
        - Purpose: Test spells, character movement, and UI.
        - High priority for initial development.
    - **Ranked 5v5 (Capture the Point):**
        - Two teams of 5 players.
        - Small, focused map with 3-5 capture points.
        - Objective: Capture and hold points to accrue score. First to X score or highest score at time limit wins.
    - **Unranked 16v16 (Arathi Basin Style):**
        - Two teams of 16 players.
        - Larger map with 5-7 capture points (e.g., Farm, Stables, Sawmill, Gold Mine, Blacksmith).
        - Objective: Control points to generate resources/score. First to X resources wins.
    - **Unranked 32v32 (Alterac Valley Style - Stretch Goal):**
        - Two teams of 32 players.
        - Massive map with multiple objectives (capture points, destroying enemy structures, defeating mini-bosses).
        - Objective: Kill the enemy faction's main boss (e.g., a powerful Golem). Requires coordinated attacks on sub-objectives to weaken boss defenses. This is a significant stretch goal and might be simplified or deferred.
- **Bots:** Crucial for initial development and player base scaffolding. Bots should fill empty player slots, allowing for testing of larger game modes. Their AI behavior will be a core development task.

---

### 6. Initial Development Iteration Plan (MVP Focus)

1. **Project Setup:** Basic MonoGame project structure in Visual Studio Code.
2. **Main Menu:** Implement a functional Main Menu with "Load Game" and "Quit" buttons.
3. **Basic 3D Rendering:** Display a single white cube (player placeholder) in a 3D space with a simple camera.
4. **Player Movement:** Implement WASD movement and mouse-look for the cube.
5. **Character Creation (Placeholder):** A simple form to input a character name **and select a base class (Brawler, Ranger, or Spellcaster)**.
6. **Training Grounds:**
    - Spawn the player cube (with chosen class's resource bar) in a simple block-based environment (e.g., a flat ground plane with walls).
    - Spawn several static "training dummy" cubes.
    - Implement basic click-to-target functionality for dummies.
    - Implement a placeholder 8-slot spell bar UI.
    - Implement 1-2 very basic spell mechanics **specific to the chosen class** (e.g., a "Magic Missile" for Spellcaster, a "Slam" for Brawler, a "Multi-shot" for Ranger).
    - Implement rudimentary health bars for dummies and player.
    - Basic spell casting with class-specific resource cost and cooldown.

---

### 7. AI/LLM Integration Strategy

- **Code Generation:** Leverage LLMs (e.g., GitHub Copilot, dedicated prompts) to generate C# classes for:
    - `SpellData` structures, including boilerplate for various effects.
    - **Base `Character` class, with derived `Brawler`, `Ranger`, and `Spellcaster` classes implementing class-specific resources and abilities.**
    - `Mob` base classes with health, movement, and targeting logic.
    - UI element rendering and interaction.
    - Game state management.
    - Network serialization/deserialization.
    - Bot AI behaviors (pathfinding, decision trees).
- **Code Refinement & Optimization:** Ask LLMs to analyze existing C# code for performance bottlenecks, clarity, and adherence to best practices.
- **Debugging & Error Resolution:** Provide error messages and ask LLMs for potential causes and fixes.
- **Concept Expansion:** Prompt LLMs for ideas on new spell mechanics **within each class's theme**, game mode variations, or subtle gear stats once core systems are in place.
- **Documentation:** Generate comments, summaries, and internal documentation for complex code sections.
- **Testing Scenarios:** Generate test cases for spell interactions, physics, and bot behavior.



--------------------------------------------------------------------------------
File: UI\Button.cs
--------------------------------------------------------------------------------
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using System;

namespace project_axiom.UI
{
    public class Button
    {
        private Texture2D _texture; // Optional: for button background image
        private SpriteFont _font;
        private string _text;
        private Vector2 _position;
        private Rectangle _rectangle;
        private bool _isHovering;
        private MouseState _previousMouse;
        private MouseState _currentMouse;

        public event EventHandler Click;
        public bool Clicked { get; private set; }
        public Color PenColour { get; set; } = Color.White; // Text color
        public Color HoverColour { get; set; } = Color.LightGray; // Text color on hover
        public Color BackgroundColour { get; set; } = Color.DarkSlateGray; // Default button background
        public Color BackgroundHoverColour { get; set; } = Color.SlateGray; // Button background on hover
        public Vector2 Position
        {
            get { return _position; }
            set
            {
                _position = value;
                UpdateRectangle();
            }
        }
        public string Text { get { return _text; } }

        public Button(SpriteFont font, string text, Texture2D texture = null)
        {
            _font = font;
            _text = text;
            _texture = texture; // Can be null if using solid color background
        }

        private void UpdateRectangle()
        {
            var textSize = _font.MeasureString(_text);
            int width = _texture?.Width ?? (int)textSize.X + 20; // Add padding if no texture
            int height = _texture?.Height ?? (int)textSize.Y + 10; // Add padding if no texture
            _rectangle = new Rectangle((int)_position.X, (int)_position.Y, width, height);
        }

        public void Update(GameTime gameTime)
        {
            _previousMouse = _currentMouse;
            _currentMouse = Mouse.GetState();
            var mouseRectangle = new Rectangle(_currentMouse.X, _currentMouse.Y, 1, 1);

            _isHovering = false;
            Clicked = false;

            if (mouseRectangle.Intersects(_rectangle))
            {
                _isHovering = true;
                if (_currentMouse.LeftButton == ButtonState.Released && _previousMouse.LeftButton == ButtonState.Pressed)
                {
                    Click?.Invoke(this, EventArgs.Empty);
                    Clicked = true;
                }
            }
        }

        public void Draw(SpriteBatch spriteBatch)
        {
            // Draw background
            Color currentBgColor = _isHovering ? BackgroundHoverColour : BackgroundColour;
            if (_texture != null)
            {
                spriteBatch.Draw(_texture, _rectangle, _isHovering ? Color.LightGray : Color.White); // Modulate texture color on hover
            }
            else
            {
                Texture2D tempTexture = new Texture2D(spriteBatch.GraphicsDevice, 1, 1);
                tempTexture.SetData(new[] { currentBgColor });
                spriteBatch.Draw(tempTexture, _rectangle, Color.White);
                tempTexture.Dispose(); // Dispose of the temporary texture
            }

            // Draw text
            if (!string.IsNullOrEmpty(_text))
            {
                var x = (_rectangle.X + (_rectangle.Width / 2f)) - (_font.MeasureString(_text).X / 2f);
                var y = (_rectangle.Y + (_rectangle.Height / 2f)) - (_font.MeasureString(_text).Y / 2f);
                spriteBatch.DrawString(_font, _text, new Vector2(x, y), _isHovering ? HoverColour : PenColour);
            }
        }
    }
}

