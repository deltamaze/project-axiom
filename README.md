## Game Design Document: Block Brawlers (Working Title) - Revised

**Document Version:** 1.1 **Date:** May 30, 2025 **Platform:** PC (Windows/macOS/Linux) via MonoGame **Development Focus:** Code-first, AI-assisted development in Visual Studio Code. Minimal reliance on visual editors.

---

### 1. Game Overview

"Block Brawlers" is a multiplayer online battleground (MOB) game with a **class-based progression system that emphasizes flexible spell selection and team synergy**. Players customize blocky, pixel-art characters, choose a **base class (Brawler, Ranger, or Spellcaster)**, and then select from a curated pool of **~30 class-specific spells** to equip 8 active abilities for battle. The core experience is driven by player choice, tactical execution, and cooperative gameplay within large-scale team battles.

### 2. Core Game Loop

1. **Launch Game:** Player launches the MonoGame application.
2. **Main Menu:** Accesses Character Creation, Game Modes, Settings, and Quit.
3. **Character Creation:** Design a pixelated character (body shape, color, simple textures), **then choose a base class (Brawler, Ranger, or Spellcaster)**.
4. **Spell Selection:** From a pool of approximately 30 spells specific to the chosen base class, select 8 active spells for the action bar.
5. **Queue for Game Mode:** Select a desired multiplayer battleground (5v5, 16v16, 32v32) or a training/practice area.
6. **Multiplayer Battleground:** Engage in objective-based PvP combat, earning experience and currency.
7. **Post-Game:** View results, earn rewards, return to main menu or re-queue.
8. **Progression:** Use earned currency to acquire new gear (minor stat improvements, aesthetic). All class spells are available from the start; there's no unlocking of additional spells within your chosen class.

### 3. Visuals & Art Style

- **Aesthetic:** Low-poly, pixelated, "boxy" art style reminiscent of early 3D games or Minecraft.
- **Characters/Mobs:** Composed entirely of textured blocks/cuboids. No traditional skeletal animation; movement will be achieved through rigid body rotations and translations of block components.
- **Environments:** Maps constructed from large, textured blocks, creating clear pathways, chokepoints, and objectives.
- **Textures:** Low-resolution, pixel-art textures applied to block surfaces to define details and materials.
- **Spells:** Visual effects for spells will be particle-based and programmatic, matching the pixelated aesthetic.
- **User Interface (UI):** Clean, functional, pixel-art inspired UI elements (buttons, health bars, spell icons) rendered directly via code.

---

### 4. Technical Requirements & Architecture Philosophy

- **Engine:** MonoGame (C#).
- **Development Environment:** Visual Studio Code.
- **Core Principle:** All game logic, UI, entity definitions, and game mode rules will be implemented in C# code. 3D assets will be defined programmatically (e.g., cube meshes generated by code) or loaded as simple, text-based data (e.g., OBJ files with associated texture paths). Textures will be simple 2D image files.
- **Networking:** Client-server architecture. Dedicated game servers for multiplayer matches. Players connect as clients.
- **Physics:** Integration of a suitable C# physics library (e.g., JoltPhysics.NET, BEPUphysics v2) for character collision, spell projectiles, and environmental interactions.
- **AI (Bots):** Implement sophisticated bot AI to fill game modes, assist with player base establishment, and provide testing capabilities. Bots should demonstrate pathfinding, target prioritization, spell usage, and objective awareness.
- **Data Serialization:** Game data (character saves, spell definitions, gear properties, map layouts) will be stored and loaded using structured formats (e.g., JSON, XML, or custom binary formats) to facilitate AI understanding and manipulation.

---

### 5. Gameplay Mechanics

#### 5.1. Character & Combat

- **Character Model:** Player character composed of basic block primitives (head, torso, arms, legs). Movement handled by translating and rotating these blocks.
- **First-Person Perspective:** Primary gameplay view is first-person. Third-person view (optional, lower priority) could be added later for character admiration.
- **Movement:** Standard WASD movement, space for jump, mouse for camera look. Sprinting mechanic.
- **Targeting:**
    - **Click-to-target:** Clicking on an enemy within a certain range highlights and locks onto them for single-target spells.
    - **Reticle-based (Skillshot):** Many spells will be skillshots, requiring direct aiming with a mouse reticle.
    - **Area-of-Effect (AoE):** Spells with a defined radius around the player or a targeted location.
- **Spell Casting:**
    - **Action Bar:** 8 customizable spell slots bound to hotkeys (1-8).
    - **Resource System:** Spells consume a class-appropriate resource (e.g., Mana for Spellcasters, Frenzy/Stamina for Brawlers, Energy for Rangers). Regeneration over time.
    - **Cooldowns:** Each spell has an individual cooldown.
- **Health System:** Player has a health pool. Damage reduces health. Reaching 0 health results in death.
- **Death & Respawn:** Players respawn after a short delay at a designated spawn point in battlegrounds.
- **Damage Types:** Spells can inflict different damage types (e.g., Arcane, Fire, Frost, Physical). Resistance/vulnerability system (lower priority).

#### 5.2. Base Classes & Spells

Players choose one of three base classes, each with its own thematic focus, armor type, primary resource, and a unique pool of approximately **30 spells** from which to select their 8 active abilities.

- **1. Spellcaster:**
    
    - **Theme:** Focuses on magical abilities, ranged combat, and elemental manipulation.
    - **Armor:** Light Armor (lowest base defense).
    - **Resource:** Mana (regenerates slowly, often replenished by specific spells or passive effects).
    - **Spell Examples:** Fireball, Ice Shard, Arcane Missile, Healing Word, Shield Bubble, Teleport, Chain Lightning, Polymorph, Mass Dispel, Blizzard, Drain Life, Summon Imp.
    - **Gameplay Role:** High burst damage, crowd control, healing, utility. Squishy but powerful.
    - **Inspiration:** Warlock, Mage, Priest.
- **2. Ranger:**
    
    - **Theme:** Focuses on agility, precision, stealth, and nature-based abilities.
    - **Armor:** Medium Armor (balanced defense).
    - **Resource:** Energy (regenerates quickly, often used for rapid, low-cooldown abilities).
    - **Spell Examples:** Multi-shot, Explosive Arrow, Stealth, Dash, Bear Trap, Healing Touch (minor self/ally heal), Poison Dart, Vine Snare, Beast Companion (temporary summon), Fan of Knives, Blind.
    - **Gameplay Role:** Sustained damage, mobility, debuffs, traps, opportunistic strikes.
    - **Inspiration:** Hunter, Rogue, Thief, Druid.
- **3. Brawler:**
    
    - **Theme:** Focuses on melee combat, durability, physical prowess, and direct confrontation.
    - **Armor:** Heavy Armor (highest base defense).
    - **Resource:** Frenzy/Stamina (generated by dealing/taking damage, or slowly over time; used for powerful offensive/defensive abilities).
    - **Spell Examples:** Charge, Slam, Taunt, Shield Wall (damage reduction), Cleave, Hamstring (slow), Ground Pound (AoE stun), Intercept, Battle Cry (team buff), Execute, Impenetrable Skin.
    - **Gameplay Role:** Tanking, front-line damage, disruptive crowd control, area denial.
    - **Inspiration:** Warrior, Death Knight, Paladin.
- **Spell Definition:** Each spell will be defined by a structured C# class or data object (e.g., `SpellData` containing name, description, resource cost, cooldown, range, damage type, cast time, and references to associated visual effects and sound effects). This is a prime area for AI assistance in defining and balancing.
    

#### 5.3. Gear & Progression

- **Gear Slots:** Head, Chest, Legs, Hands, Feet, Weapon, Trinket (2).
- **Stat Increments:** Gear provides minor statistical improvements (e.g., +Health, +Resource Pool, +Spell Power, +Cooldown Reduction). Each class benefits more from certain stats.
- **Power Ceiling:** Earned gear should provide a maximum of **10%** statistical advantage over base/starter gear. This ensures skill remains paramount.
- **Acquisition:** Earned through playing game modes (rewards for winning, performance).
- **Cash Store (Future):** Cosmetic items only. No pay-to-win elements. Aesthetic gear from the cash store should _never_ be statistically better than earned gear. This is a low-priority feature for initial development.

#### 5.4. Multiplayer & Game Modes

- **Lobby/Queue System:** Players queue for desired game modes.
- **Matchmaking:** Simple matchmaking based on queue time and game mode selection. (No complex ELO/MMR initially).
- **Dedicated Servers:** Game logic resides on dedicated servers, with clients sending input and receiving game state.
- **Game Modes:**
    - **Training Grounds:**
        - Single-player instance with static training dummies.
        - No time limit.
        - Purpose: Test spells, character movement, and UI.
        - High priority for initial development.
    - **Ranked 5v5 (Capture the Point):**
        - Two teams of 5 players.
        - Small, focused map with 3-5 capture points.
        - Objective: Capture and hold points to accrue score. First to X score or highest score at time limit wins.
    - **Unranked 16v16 (Arathi Basin Style):**
        - Two teams of 16 players.
        - Larger map with 5-7 capture points (e.g., Farm, Stables, Sawmill, Gold Mine, Blacksmith).
        - Objective: Control points to generate resources/score. First to X resources wins.
    - **Unranked 32v32 (Alterac Valley Style - Stretch Goal):**
        - Two teams of 32 players.
        - Massive map with multiple objectives (capture points, destroying enemy structures, defeating mini-bosses).
        - Objective: Kill the enemy faction's main boss (e.g., a powerful Golem). Requires coordinated attacks on sub-objectives to weaken boss defenses. This is a significant stretch goal and might be simplified or deferred.
- **Bots:** Crucial for initial development and player base scaffolding. Bots should fill empty player slots, allowing for testing of larger game modes. Their AI behavior will be a core development task.

---

### 6. Initial Development Iteration Plan (MVP Focus)

1.  **Project Setup:** Basic MonoGame project structure in Visual Studio Code.
2.  **Main Menu:** Implement a functional Main Menu with "Load Game" and "Quit" buttons.
3.  **Basic 3D Rendering:** Display a single white cube (player placeholder) in a 3D space with a simple camera.
4.  **Player Movement:** Implement WASD movement and mouse-look for the cube.
5.  **Character Creation (Placeholder):** A simple form to input a character name and select a base class (**Brawler, Ranger, or Spellcaster**).
6.  **Basic Environment Creation:**
    * Create a simple flat ground plane.
    * Add basic boundary walls to define the training area.
    * Ensure the player cube (from step 6.1) spawns correctly on this ground plane.
7.  **Static Training Dummy Placement:**
    * Create a simple "training dummy" cube asset (can be a different color or slightly different size than the player cube).
    * Manually place 2-3 static training dummy cubes at fixed positions within the environment.
8.  **Player Resource Bar (Class-Specific):**
    * Based on the class chosen in step 5, display a simple UI bar representing their primary resource (e.g., **Mana** for Spellcaster, **Frenzy** for Brawler, **Energy** for Ranger). For now, this can just be a colored rectangle.
9.  **Click-to-Target System:**
    * Implement functionality to detect when the player clicks on a training dummy.
    * Visually indicate the currently targeted dummy (e.g., highlight it or show its name/health).
10. **Placeholder Spell Bar UI:**
    * Create a static UI element at the bottom of the screen with 8 empty slots to represent the spell bar. No functionality yet, just the visual representation.
11. **Rudimentary Health System & Display:**
    * Give the player cube a health value.
    * Give each training dummy a health value.
    * Display simple health bars above the player and targeted dummy (or all dummies). These can be basic colored rectangles.
12. **Implement ONE Basic Spell/Attack (Brawler - "Slam"):**
    * If **Brawler** is chosen: Design a simple melee-range "**Slam**" ability.
    * When the ability is used (e.g., pressing '1'), if a dummy is targeted and in range, reduce the dummy's health.
    * Implement a basic resource cost (**Frenzy**) for using "**Slam**."
    * Implement a short cooldown for "**Slam**."
13. **Skip:**
14. **Skip:**
15. **Basic "Death" State for Dummies:**
    * When a dummy's health reaches zero, make it disappear or change appearance to indicate it's defeated.
16. **(Optional) Dummy Respawn:**
    * After a short delay, make defeated dummies reappear.
17. **Basic Player "Death" (Placeholder):**
    * If player health reaches zero, display a "You are defeated" message. No need for complex respawn logic yet.
18. **Project Scaffolding & Shared Logic:**
    * Create two new projects within your solution: BlockBrawlers.Server (a Console Application) and BlockBrawlers.Shared (a Class Library).
    * Move any data structures that need to be understood by both client and server into the Shared project (e.g., Vector3, PlayerData, SpellData classes). Both the client and server projects will reference this.
19. **Basic Network Communication Layer:**
    * Using a library like WebSocketSharp or .NET's built-in System.Net.WebSockets, implement the most basic connection.
    * Server: Listens for incoming WebSocket connections.
    * Client: On launch, attempts to connect to the server's address.
    * Goal: Successfully log "Client connected" on the server and "Connected to server" on the client. This is the "Hello World" of your network code.
20. **Persistence Abstraction (IDatabase):**
    * In the Server project, define an interface, IDatabaseService.
    * In the Shared project, define CharacterData (Data Transfer Object class).
    * Define methods like Task<CharacterData> GetCharacterAsync(string characterId) and Task SaveCharacterAsync(CharacterData character).
    * In the Server project, create a class FileSystemDatabaseService : IDatabaseService. Implement the methods by reading from and writing to local JSON files (characterId.json).
21. **Dependency Injection (DI) Setup:**
    * Introduce a DI container (like Microsoft.Extensions.DependencyInjection) to both the client and server projects.
    * Server: Register your FileSystemDatabaseService as the implementation for IDatabaseService.
    * This makes your code loosely coupled and easier to test and maintain from the start.
22. **Basic "Login" and Character Loading:**
    * Refactor the client's Character Selection screen.
    * When the player enters a name and clicks "Load Game," the client sends a RequestCharacterLoad message to the server with the character name.
    * The server receives the message, uses the IDatabaseService to find and load the character's JSON file, and sends a CharacterDataResponse back to the client. The client now holds the data for the selected character.
23. **Game Session Management on Server:**
    * Create a GameSessionManager on the server. Its job is to manage active game instances (for now, just Training Grounds).
    * When a client requests to enter the Training Grounds, the manager creates a new GameSession, gives it a unique ID, and adds the player to it. This prepares you for handling multiple, separate 16v16 matches in the future.
24. **Entering the World (Server-Driven):**
    * When the client gets the green light to join a game session, the server sends an initial JoinSessionSuccess message.
    * This message contains the essential starting data: the map to load ("TrainingGrounds") and the player's starting position. The client no longer decides this for itself.
25. **Server-Authoritative Dummies:**
    * Move the logic for placing and managing Training Dummies (Step 7) to the server.
    * When a GameSession for the Training Grounds is created, the server spawns the dummy entities in its memory.
    * The server then sends messages to all clients in the session telling them where to render the dummies and what their health is.
26. **Authoritative Movement (Server-Side Logic):**
    * On the server, create the core movement logic. It should receive simple input states from the client (e.g., isMovingForward: true, isJumping: true, yaw: 95.4).
    * The server will run its own physics tick, calculating the player's new position based on the input and server-side collision detection (e.g., "Is the player trying to walk through a wall?"). The server now holds the player's true position.
27. **Client-Side Prediction (The "Fluidity" part):**
    * On the client, when the player presses 'W', continue to move the character immediately, just as you do now. This is the prediction.
    * Simultaneously, the client packages up the input state and sends it to the server every frame or on a fixed interval.
28. **State Synchronization & Reconciliation (The "Anti-Cheat" part):**
    * The server, on a fixed tick (e.g., 20 times per second), broadcasts the authoritative state of all entities (players, dummies) to every client in the session.
    * The client receives this state update. It compares its predicted position with the authoritative position sent by the server.
    * If they are different, the client must correct its position to match the server's. This is the reconciliation that prevents speed hacking and fixes desync.
29. **Unit Testing Framework Setup:**
    * Create a new Unit Test project (e.g., using xUnit, NUnit).
    * Write your first simple test. A great candidate is a "pure" function, like a test for a spell's damage calculation or verifying that your FileSystemDatabaseService correctly saves and loads a JSON file.
30. **Refactor Click-to-Target:**
    * The client no longer decides its target. When the player clicks a dummy, the client sends a RequestSetTarget(dummyId) message.
    * The server validates this request (is the dummy in line of sight? in range?). If valid, it sets the player's target in its game state and notifies the client: TargetChanged(dummyId).
    * The client's UI updates only after receiving confirmation from the server.
31. **Refactor Spell Casting (The Full Loop):**
    * This combines everything. Refactor one of your class spells (e.g., Brawler's "Slam").
    * Client: Pressing '1' sends RequestCastSpell("Slam").
    * Server: Receives request. Validates everything: Is the player a Brawler? Do they have a valid target? Is the target in melee range (based on authoritative positions)? Is the spell off cooldown? Do they have the Frenzy?
    * Server: If all checks pass, the server executes the logic: it reduces the dummy's health and starts the spell's cooldown timer on the server.
    * Server: It broadcasts the results: PlayerX_HealthChanged(newHealth), PlayerX_SpellUsed("Slam").
    * Client: Receives these messages and plays the visual/audio effects and updates the dummy's health bar.
32. **Saving Character State on Exit:**
    * Implement a Disconnect message. When the client closes or sends this message, the server should take the player's current state from the GameSession and save it back to the JSON file using the IDatabaseService. This will save their position, health, etc.
33. **Persisting Spell Bar and Gear:**
    * Expand the CharacterData class in the Shared project to include List<string> EquippedSpells and Dictionary<GearSlot, GearItem> EquippedGear.
    * Update the server's character loading/saving logic to handle this new data. For now, the gear can just be placeholder data.
34. **Expanded UI Shell:**
    * In the client's Main Menu, add the buttons for the other game modes ("5v5 Capture Point," "16v16 Battleground"). Have them be disabled or lead to a "Coming Soon!" message. This builds the framework for future expansion.
35. **Server Logging:**
    * Implement basic logging on the server (e.g., writing to a text file or the console). Log important events: server start, player connect/disconnect, session creation, and potential errors. This is invaluable for debugging.
36. **Basic Player Respawn (Server-Side):**
    * Move the death/respawn logic (Steps 15-17) to the server. When a player's or dummy's health reaches zero, the server marks them as "dead" and starts a respawn timer. When the timer completes, the server changes their state back to "alive," sets their health to full, moves them to a spawn point, and informs all clients of these changes.
37. **Implement ONE Basic Spell/Attack (Ranger - "Multi-shot"):**
    * If **Ranger** is chosen: Design a simple ranged "**Multi-shot**" ability.
    * When the ability is used, if a dummy is targeted, "fire" a projectile (can be a small cube for now) that reduces the dummy's health on impact.
    * Implement a basic resource cost (**Energy**) for "**Multi-shot**."
    * Implement a short cooldown for "**Multi-shot**."
38. **Implement ONE Basic Spell/Attack (Spellcaster - "Magic Missile"):**
    * If **Spellcaster** is chosen: Design a simple ranged "**Magic Missile**" ability.
    * When the ability is used, if a dummy is targeted, "fire" a projectile that reduces the dummy's health on impact.
    * Implement a basic resource cost (**Mana**) for "**Magic Missile**."
    * Implement a short cooldown for "**Magic Missile**."
---

### 7. AI/LLM Integration Strategy

- **Code Generation:** Leverage LLMs (e.g., GitHub Copilot, dedicated prompts) to generate C# classes for:
    - `SpellData` structures, including boilerplate for various effects.
    - **Base `Character` class, with derived `Brawler`, `Ranger`, and `Spellcaster` classes implementing class-specific resources and abilities.**
    - `Mob` base classes with health, movement, and targeting logic.
    - UI element rendering and interaction.
    - Game state management.
    - Network serialization/deserialization.
    - Bot AI behaviors (pathfinding, decision trees).
- **Code Refinement & Optimization:** Ask LLMs to analyze existing C# code for performance bottlenecks, clarity, and adherence to best practices.
- **Debugging & Error Resolution:** Provide error messages and ask LLMs for potential causes and fixes.
- **Concept Expansion:** Prompt LLMs for ideas on new spell mechanics **within each class's theme**, game mode variations, or subtle gear stats once core systems are in place.
- **Documentation:** Generate comments, summaries, and internal documentation for complex code sections.
- **Testing Scenarios:** Generate test cases for spell interactions, physics, and bot behavior.
